<!DOCTYPE html>
<html lang="ru">
<head>
        <meta charset="utf-8" />
        <title>Список всего - Remote Sensing</title>
        <link rel="stylesheet" href="https://kolesovdmitry.github.io/logbook/theme/css/main.css" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="https://kolesovdmitry.github.io/logbook/">Список всего </a></h1>
                <nav><ul>
                    <li><a href="https://kolesovdmitry.github.io/logbook/category/change-detection.html">Change Detection</a></li>
                    <li><a href="https://kolesovdmitry.github.io/logbook/category/gee.html">GEE</a></li>
                    <li><a href="https://kolesovdmitry.github.io/logbook/category/neuralnets.html">NeuralNets</a></li>
                    <li><a href="https://kolesovdmitry.github.io/logbook/category/raster-processing.html">Raster Processing</a></li>
                    <li><a href="https://kolesovdmitry.github.io/logbook/category/review.html">Review</a></li>
                </ul></nav>
        </header><!-- /#banner -->

            <aside id="featured" class="body">
                <article>
                    <h1 class="entry-title"><a href="https://kolesovdmitry.github.io/logbook/zamechaniia-po-organizatsii-obrabotki-rastrov.html">Замечания по организации обработки растров</a></h1>
<footer class="post-info">
        <abbr class="published" title="2020-02-05T00:00:00+03:00">
                Published: Ср 05 февраля 2020
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://kolesovdmitry.github.io/logbook/author/dmitry-kolesov.html">Dmitry Kolesov</a>
        </address>
<p>In <a href="https://kolesovdmitry.github.io/logbook/category/raster-processing.html">Raster Processing</a>.</p>
<p>tags: <a href="https://kolesovdmitry.github.io/logbook/tag/remote-sensing.html">Remote Sensing</a> <a href="https://kolesovdmitry.github.io/logbook/tag/gee.html">GEE</a> <a href="https://kolesovdmitry.github.io/logbook/tag/grass.html">GRASS</a> <a href="https://kolesovdmitry.github.io/logbook/tag/tensorflow.html">TensorFlow</a> </p>
</footer><!-- /.post-info --><p>По результатам работы над поиском водных объектов хочется оставить несколько замечаний, касающихся удобств/неудобств обработки большого числа космосьемки
при помощи того или иного ПО.</p>
<h2>Общая характеристика обработки</h2>
<h3>Особенности методики</h3>
<p><a href="https://kolesovdmitry.github.io/logbook/development-of-a-global-90-m-water-body-map-using-multi-temporal-landsat-images.html">Методика поиска водных объектов</a> имеет несколько особенностей, характерных для конкретно этой задачи.</p>
<ol>
<li>Активная работа с различными каналами по различным формулам. Имеется в виду, что, к примеру, в отличие от классических методов машинного обучения
 (нейросети, деревья решений, логистической регрессии и т.п.) в этой методике каждый канал обрабатывается по своему. Другими словами, в методике нет схемы обработки, единой для
 всех каналов такой, к примеру, как умножение матриц для регрессий/нейросетей или единообразного разбиения пространства признаков деревьями.</li>
<li>Групповая обработка пикселей: согласно методике, следует анализировать не только отдельные пиксели или скользящие окна, но и группы связанных пикселей, то есть
 по сути требуется сначала произвести сегментацию, а затем в каждом выделенном участке собарать зональные статистики и передать их на следующий этап обработки.</li>
<li>Хотя сама методика довольно проста, но она оперирует параметрами, которые подбирались авторами "на глаз" и на другую территорию и (главное!) для другого сенсора;
 поэтому для того чтобы получить хороший результат в наших условиях требуется оптимизация параметров алгоритма на наших данных.</li>
</ol>
<h3>Особенности данных</h3>
<p>Помимо специфических требований конкретной методики, возникают также дополнительные ограничения, вытекающие из необходимости обрабатывать большую территорию. В итоге это
приводит к следующим особенностям:</p>
<ol>
<li>Большое количество данных: в область интересов попадает свыше 13 тыс. сцен Sentinel-2 (за два интересующих нас года, причем, это только летних снимков).</li>
<li>Большая территория влечет за собой большое разнообразие ландшафтов, отдельное удовольствие доставляет не только широтная, но и высотная поясность; в
 итоге нельзя работать только в одном "углу" области интересов, приходится экспериментировать сразу на всем объеме.</li>
<li>Большая территория подразумевает перепроецирование исходных сцен, т.к. космосьемка приходит в разных проекциях в зависимости от места съемки;</li>
<li>Чтобы не "гонять" тестовые алгоритмы на слишком больших данных удобно менять разрешение снимков "на лету", что позволяет снизить количество обрабатываемых данных
 в ходе экспериментов (т.е. огрубить снимки и быстро прикинуть результат).</li>
</ol>
<h3>Вывод</h3>
<p>Идеальный инструмент для этой задачи должен уметь:</p>
<ol>
<li>Обрабатывать десятки террабайт космоснимков.</li>
<li>Организовывать удобную работу с отдельными каналами (растровую алгебру, аггрегирование и прочее).</li>
<li>Считать зональные статистики.</li>
<li>Позволять оптимизацию параметров.</li>
<li>Стандартные ГИСовские штучки - перепроецирование, смена разрешения и прочие классические вещи.</li>
<li>Возможность использования того или иного языка программирования, чтобы склеивать между собой различные этапы и для написания скриптов.</li>
<li>(не обязательно, но желательно) Развитая библиотека уже готовых методов обработки, в частности классификаторов и оптимизаторов.</li>
</ol>
<h2>Работа в Google EarthEngine</h2>
<p>GEE на первый взгляд устраивает всем, особенно подкупает то, что в нем из коробки организован доступ к данным ДЗЗ и не требуется предварительное выкачивание
снимков. Также большое преимущество - скорость их обработки. Есть недостатки - лимиты на вычисления, в которые нет-нет, да и упираешься, в результате приходится
придумывать обходные пути (но это условный недостаток, т.к. лимиты есть в любых условиях).</p>
<p>Главная проблема GEE -- то, что у него очень ограничена возможность работы с зональной статистикой. GEE хранит данные у себя на серверах в виде тайлов 256x256 пикселей
в итоге для того, чтобы посчитать зональную статистику есть два пути:</p>
<ul>
<li>использовать функцию ee.Image.reduceConnectedComponents(), но она может работать только с объектами (зонами), протяженностью не более 256 пикселей; все, что выше - будет сброшено
в No-Data;</li>
<li>если предыдуший вариант не устраивает, можно произвести векторизацию зон через функцию ee.Image.reduceToVectors() и считать статистики внутри векторных данных,
однако на большом объеме пикселей эта функция не будет работать из-за нехватки памяти (приходится или уменьшать территорию, или снижать разрешение).</li>
</ul>
<p>Итак GEE - очень хороший кандидат, но в данном конкретном случае все портит проблема зональной статистики.</p>
<h2>Связка TensorFlow и GEE</h2>
<p>Конечно, немного странно писать тут про TensorFlow, поскольку TF предназначен для других целей. Но упоминаю о нем, т.к. модели TF можно использовать напрямую в GEE,
что сильно расширяет возможности GEE (и частично снимает проблему зональных статистик на растрах).
Обычно, конечно, в GEE подключается нейросетевая модель, обученная в TF, но никто не запрещает использовать и другие модели. В нашем случае TF
хорош еще и тем, что в нем очень удобно производить оптимизацию параметров (собственно, для чего TF и создавался) -- очень распространенная задача в анализе ДЗЗ.</p>
<p>Но при выносе требуемой нам модели на уровень TF возникают сложности, связанные с тем, что в TF очень неудобно работать с отдельными каналами и растрами. По большому счету все, с чем человек
имеет дело при работе с TF - это многомерный массив. До тех пор, пока программисту не нужно обрабатывать отдельные измерения массива (в нашем случае - каналы) по специфическим
схемам обработки, все будет хорошо, но как только требуется достучаться до отдельного канала, приходится писать что-то вроде <code>Image[:, :, band_number, ;, ....]</code> и код очень быстро
замусовривается и становится нечитаемым.</p>
<p>Бороться с подобным можно, создавая объекты-обертки и организуя в них доступ к отдельным срезам данных. Выглядит это как-то так:</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">YamazakiModel</span><span class="p">:</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scene_count</span><span class="p">,</span> <span class="n">band_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;green&#39;</span><span class="p">,</span><span class="s1">&#39;red&#39;</span><span class="p">,</span><span class="s1">&#39;nir&#39;</span><span class="p">,</span><span class="s1">&#39;swir1&#39;</span><span class="p">,</span><span class="s1">&#39;tir2&#39;</span><span class="p">]):</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">scene_count</span> <span class="o">=</span> <span class="n">scene_count</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">band_names</span> <span class="o">=</span> <span class="n">band_names</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">SCALE</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="mf">15.0</span><span class="p">)</span>
<span class="o">...</span>   
    <span class="c1"># Перечисляются параметры модели, которые нужно оптимизировать:</span>
    <span class="c1"># NDLI PARAMS</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">NDLI_MIN</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">NDLI_MAX</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="o">...</span>

    <span class="c1"># Прописываются свойства доступа к отдельным каналам</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scene_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">band_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="mi">2</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">green_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;green&#39;</span><span class="p">)</span>
<span class="o">...</span>

    <span class="c1"># Доступ каналам:</span>
    <span class="k">def</span> <span class="nf">_band</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">sample</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">index</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

    <span class="k">def</span> <span class="nf">green</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_band</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">green_idx</span><span class="p">)</span>
<span class="o">...</span>

    <span class="c1"># Использование в самой модели</span>
    <span class="k">def</span> <span class="nf">ndli</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample</span><span class="p">):</span>
      <span class="n">red</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">red</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
      <span class="n">nir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nir</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
      <span class="n">green</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">green</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
      <span class="n">swir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">swir</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>

      <span class="n">gr</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">)</span>
      <span class="n">ns</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">nir</span><span class="p">,</span> <span class="n">swir</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">f_ndli</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample</span><span class="p">):</span>
      <span class="n">ndli</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndli</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
      <span class="n">k</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NDLI_MIN</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">NDLI_MAX</span><span class="p">)</span>
      <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">NDLI_MAX</span> <span class="o">*</span>  <span class="n">k</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">ndli</span> <span class="o">+</span> <span class="n">b</span>

      <span class="n">result</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">result</span>
<span class="o">...</span>
</pre></div>


<p>В конечном итоге за счет написания подобных оберток сам процесс подбора параметров становится более-менее комфортным. Но зато:</p>
<ul>
<li>оберточного кода нужно очень много, по сути приходится писать чуть ли не свою растровую ГИС, но только на массивах;</li>
<li>оберточный код тоже довольно сложен: все более-менее прямолинейно до тех пор, пока не появляется свертка или аггрегация
 по одной из размерностей, в результате чего  меняется размерность массива и вся нумерация каналов летит к чертям.</li>
</ul>
<p>Выигрыш же от использования связки GEE+TF в этой задаче не очень большой -- тайловая архитектура никуда не девается. Правда,
за счет внешнего кода мы можем играть размерами скользящего окна при обработке, но это не дает кардинального улучшения.</p>
<p>Из прочих минусов - отсутствие типично ГИСовских операций типа поддержки проекций и растров с различным разрешением пикселя.</p>
<h2>GRASS GIS</h2>
<p>Еще один тестировавшийся вариант -- посчитать все на GRASS GIS. Плюсы очевидны:</p>
<ul>
<li>полноценная ГИС с развитым инструментарием (нет проблем ни с зональной статистикой, ни с преобразованиями);</li>
<li>большие возможности скриптовой обработки;</li>
<li>встроенные классификаторы и возможноть подключения внешних (например, того же TF).</li>
</ul>
<p>Минусы так же очевидны:</p>
<ul>
<li>неудобно работать с большими данными, например, для параллельной обработки приходится в явном виде разбивать территорию на части
 (правда, в из-за ограничений по памяти в GEE в конечном итоге также приходится бить территорию на куски);</li>
<li>нужно хранить данные локально - огромный минус по сравнению с GEE, где получение данных происходит прозрачно для пользователя; в
 итоге нужно организовывать локальное хранилище данных и скачивать десятки террабайт снимков</li>
<li>считаешь все на своем железе, от которого и зависит, хватит ли ресурсов на обработку.</li>
</ul>
<h2>Выводы</h2>
<p>А выводов как таковых не будет, это скорее заметки на память по свежим следам.</p>
<p>Можно лишь сказать, что пока проклевывается такое грубое правило -- если нет ограничений на используемое ПО, тогда</p>
<ul>
<li>если задача требует попискельного подхода, то лучшее ее решать в GEE;</li>
<li>если нужно работать с небольшими окрестностями пикселей (грубо до 200 пикселей), то тоже работаем GEE, а при необходимости подключаем TF;</li>
<li>если нужно аггрегировать данные в пространстве или работать с разнородными данными,
 тогда лучше играет связка GEE+GRASS - подготовка данных к анализу производится в GEE, затем экспорт полученных результатов и последующий анализ их в GRASS GIS.</li>
</ul>                </article>
            </aside><!-- /#featured -->
                <section id="content" class="body">
                    <h1>Other articles</h1>
                    <hr />
                    <ol id="posts-list" class="hfeed">

            <li><article class="hentry">
                <header>
                    <h1><a href="https://kolesovdmitry.github.io/logbook/podbor-parametrov-modelei-dlia-gee.html" rel="bookmark"
                           title="Permalink to Подбор параметров моделей для GEE">Подбор параметров моделей для GEE</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2020-01-18T00:00:00+03:00">
                Published: Сб 18 января 2020
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://kolesovdmitry.github.io/logbook/author/dmitry-kolesov.html">Dmitry Kolesov</a>
        </address>
<p>In <a href="https://kolesovdmitry.github.io/logbook/category/gee.html">GEE</a>.</p>
<p>tags: <a href="https://kolesovdmitry.github.io/logbook/tag/remote-sensing.html">Remote Sensing</a> <a href="https://kolesovdmitry.github.io/logbook/tag/gee.html">GEE</a> </p>
</footer><!-- /.post-info -->                <p>Google EarthEngine позволяет быстро строить модели для обработки данных ДЗЗ, но в текущей версии GEE нет каких-либо
функций, которые обеспечвают поиск оптимальных параметров моделей. Возможно, они появятся позднее (GEE очень быстро
развивается), но сейчас приходится выкручиваться самостоятельно.</p>
<p>Пока самый простой в реализации способ из обнаруженных -- подбор параметров внешним скриптом. Общая …</p>
                <a class="readmore" href="https://kolesovdmitry.github.io/logbook/podbor-parametrov-modelei-dlia-gee.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="https://kolesovdmitry.github.io/logbook/sozdanie-obuchaiushchikh-dannykh-v-gee-dlia-klassifikatsii-vneshnimi-resursami.html" rel="bookmark"
                           title="Permalink to Создание обучающих данных в GEE для классификации внешними ресурсами">Создание обучающих данных в GEE для классификации внешними ресурсами</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2020-01-10T00:00:00+03:00">
                Published: Пт 10 января 2020
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://kolesovdmitry.github.io/logbook/author/dmitry-kolesov.html">Dmitry Kolesov</a>
        </address>
<p>In <a href="https://kolesovdmitry.github.io/logbook/category/gee.html">GEE</a>.</p>
<p>tags: <a href="https://kolesovdmitry.github.io/logbook/tag/remote-sensing.html">Remote Sensing</a> <a href="https://kolesovdmitry.github.io/logbook/tag/gee.html">GEE</a> </p>
</footer><!-- /.post-info -->                <p>Периодически возникает необходимость создать обучающее множество примеров на базе данных,
подготовленных к анализу в GEE.</p>
<h1>Попиксельный анализ</h1>
<p>Если планируется попиксельный анализ, то обычно все довольно просто,
нужно подготовить к анализу снимки (<a href="https://kolesovdmitry.github.io/logbook/predobrabotka-dannykh-sentinel-2-v-google-earthengine.html">см., скажем, этот пример</a>),
а затем сгенерировать набор точек и прочитать под этими точками значения яркостей каналов полученных снимков …</p>
                <a class="readmore" href="https://kolesovdmitry.github.io/logbook/sozdanie-obuchaiushchikh-dannykh-v-gee-dlia-klassifikatsii-vneshnimi-resursami.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="https://kolesovdmitry.github.io/logbook/realizatsiia-metodiki-iz-stati-development-of-a-global-90-m-water-body-map-na-baze-sentinel-2.html" rel="bookmark"
                           title="Permalink to Реализация методики из статьи "Development of a global ~90 m water body map..." на базе Sentinel-2">Реализация методики из статьи "Development of a global ~90 m water body map..." на базе Sentinel-2</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2019-12-25T00:00:00+03:00">
                Published: Ср 25 декабря 2019
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://kolesovdmitry.github.io/logbook/author/dmitry-kolesov.html">Dmitry Kolesov</a>
        </address>
<p>In <a href="https://kolesovdmitry.github.io/logbook/category/gee.html">GEE</a>.</p>
<p>tags: <a href="https://kolesovdmitry.github.io/logbook/tag/sentinel-2.html">Sentinel-2</a> <a href="https://kolesovdmitry.github.io/logbook/tag/remote-sensing.html">Remote Sensing</a> <a href="https://kolesovdmitry.github.io/logbook/tag/gee.html">GEE</a> <a href="https://kolesovdmitry.github.io/logbook/tag/water.html">Water</a> </p>
</footer><!-- /.post-info -->                <h1>Задача</h1>
<p>Ранее описывалась <a href="https://kolesovdmitry.github.io/logbook/development-of-a-global-90-m-water-body-map-using-multi-temporal-landsat-images.html">методика поиска водных объектов</a>, разработанная для Landsat. Она
позволяет строить карты постоянных водных объектов, временно затапливаемых территорий, а также похожих на них по своим спектральным свойствам участков (лед, солончаки, и т.п.).
Ниже рассматривается реализация "в лоб", выполненная в GEE на базе Sentinel-2.</p>
<h1>Сложности</h1>
<p>Исходная методика была …</p>
                <a class="readmore" href="https://kolesovdmitry.github.io/logbook/realizatsiia-metodiki-iz-stati-development-of-a-global-90-m-water-body-map-na-baze-sentinel-2.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="https://kolesovdmitry.github.io/logbook/development-of-a-global-90-m-water-body-map-using-multi-temporal-landsat-images.html" rel="bookmark"
                           title="Permalink to Development of a global ~90 m water body map using multi-temporal Landsat images">Development of a global ~90 m water body map using multi-temporal Landsat images</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2019-12-16T00:00:00+03:00">
                Published: Пн 16 декабря 2019
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://kolesovdmitry.github.io/logbook/author/dmitry-kolesov.html">Dmitry Kolesov</a>
        </address>
<p>In <a href="https://kolesovdmitry.github.io/logbook/category/review.html">Review</a>.</p>
<p>tags: <a href="https://kolesovdmitry.github.io/logbook/tag/remote-sensing.html">Remote Sensing</a> <a href="https://kolesovdmitry.github.io/logbook/tag/water.html">Water</a> <a href="https://kolesovdmitry.github.io/logbook/tag/landsat.html">Landsat</a> </p>
</footer><!-- /.post-info -->                <p><strong>Обзор статьи
<a href="https://www.sciencedirect.com/science/article/abs/pii/S0034425715301656">Development of a global ~90 m water body map using multi-temporal Landsat images</a></strong></p>
<h2>Суть дела</h2>
<p>Статья описывает то, как создавался продукт <a href="http://hydro.iis.u-tokyo.ac.jp/~yamadai/G3WBM/">Global 3 arc-second Water Body Map (G3WBM)</a>.
Этот продукт представляет собой маски постоянных и временных водных объектов, построенных на временных сериях Ландстатов (более точно -- на четырех эпохах …</p>
                <a class="readmore" href="https://kolesovdmitry.github.io/logbook/development-of-a-global-90-m-water-body-map-using-multi-temporal-landsat-images.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="https://kolesovdmitry.github.io/logbook/predobrabotka-dannykh-sentinel-2-v-google-earthengine.html" rel="bookmark"
                           title="Permalink to Предобработка данных Sentinel-2 в Google EarthEngine">Предобработка данных Sentinel-2 в Google EarthEngine</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2019-12-13T00:00:00+03:00">
                Published: Пт 13 декабря 2019
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://kolesovdmitry.github.io/logbook/author/dmitry-kolesov.html">Dmitry Kolesov</a>
        </address>
<p>In <a href="https://kolesovdmitry.github.io/logbook/category/gee.html">GEE</a>.</p>
<p>tags: <a href="https://kolesovdmitry.github.io/logbook/tag/sentinel-2.html">Sentinel-2</a> <a href="https://kolesovdmitry.github.io/logbook/tag/remote-sensing.html">Remote Sensing</a> <a href="https://kolesovdmitry.github.io/logbook/tag/gee.html">GEE</a> </p>
</footer><!-- /.post-info -->                <h1>Задача</h1>
<p>Есть большая задача -- построение маски водных объектов по данным ДЗЗ, точнее Sentinel-2. Эта задача разбивается
на множество отдельных подзадач, в частности сейчас решаем вопрос о сборе обучающих данных для алгоритмов маскирования.</p>
<p>Для решения этой частной задачи нужно собрать данные Sentinel-2 на интересующую нас территорию и:</p>
<ul>
<li>удалить с них облака …</li></ul>
                <a class="readmore" href="https://kolesovdmitry.github.io/logbook/predobrabotka-dannykh-sentinel-2-v-google-earthengine.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>
                </ol><!-- /#posts-list -->
                </section><!-- /#content -->
        <section id="extras" class="body">
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>